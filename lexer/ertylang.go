// Code generated by re2c 2.2 on Fri Aug 11 18:02:07 2023, DO NOT EDIT.
package lexer

import (
    "bytes"
    "github.com/masp/ertylang/token"
)

func (l *Lexer) lex() (pos token.Pos, tok token.Type, lit string, err error) {
    for {
		lit = ""
		pos = l.pos()
		l.token = l.cursor


{
	var yych byte
	yyaccept := 0
	yych = l.input[l.cursor]
	switch (yych) {
	case 0x00:
		goto yy2
	case '\t':
		fallthrough
	case ' ':
		goto yy6
	case '\n':
		goto yy9
	case '\r':
		goto yy11
	case '!':
		goto yy12
	case '"':
		goto yy14
	case '\'':
		goto yy16
	case '(':
		goto yy18
	case ')':
		goto yy20
	case '*':
		goto yy22
	case '+':
		goto yy24
	case ',':
		goto yy26
	case '-':
		goto yy28
	case '.':
		goto yy30
	case '/':
		goto yy32
	case '0':
		goto yy34
	case '1':
		fallthrough
	case '2':
		fallthrough
	case '3':
		fallthrough
	case '4':
		fallthrough
	case '5':
		fallthrough
	case '6':
		fallthrough
	case '7':
		fallthrough
	case '8':
		fallthrough
	case '9':
		goto yy36
	case ':':
		goto yy38
	case ';':
		goto yy40
	case '<':
		goto yy42
	case '=':
		goto yy44
	case '>':
		goto yy46
	case 'A':
		fallthrough
	case 'B':
		fallthrough
	case 'C':
		fallthrough
	case 'D':
		fallthrough
	case 'E':
		fallthrough
	case 'F':
		fallthrough
	case 'G':
		fallthrough
	case 'H':
		fallthrough
	case 'I':
		fallthrough
	case 'J':
		fallthrough
	case 'K':
		fallthrough
	case 'L':
		fallthrough
	case 'M':
		fallthrough
	case 'N':
		fallthrough
	case 'O':
		fallthrough
	case 'P':
		fallthrough
	case 'Q':
		fallthrough
	case 'R':
		fallthrough
	case 'S':
		fallthrough
	case 'T':
		fallthrough
	case 'U':
		fallthrough
	case 'V':
		fallthrough
	case 'W':
		fallthrough
	case 'X':
		fallthrough
	case 'Y':
		fallthrough
	case 'Z':
		fallthrough
	case '_':
		fallthrough
	case 'a':
		fallthrough
	case 'b':
		fallthrough
	case 'd':
		fallthrough
	case 'g':
		fallthrough
	case 'h':
		fallthrough
	case 'j':
		fallthrough
	case 'k':
		fallthrough
	case 'l':
		fallthrough
	case 'n':
		fallthrough
	case 'o':
		fallthrough
	case 'p':
		fallthrough
	case 'q':
		fallthrough
	case 's':
		fallthrough
	case 'u':
		fallthrough
	case 'v':
		fallthrough
	case 'w':
		fallthrough
	case 'x':
		fallthrough
	case 'y':
		fallthrough
	case 'z':
		goto yy48
	case '[':
		goto yy51
	case ']':
		goto yy53
	case '`':
		goto yy55
	case 'c':
		goto yy57
	case 'e':
		goto yy58
	case 'f':
		goto yy59
	case 'i':
		goto yy60
	case 'm':
		goto yy61
	case 'r':
		goto yy62
	case 't':
		goto yy63
	case '{':
		goto yy64
	case '|':
		goto yy66
	case '}':
		goto yy68
	default:
		goto yy4
	}
yy2:
	l.cursor += 1
	{ tok = token.EOF; return }
yy4:
	l.cursor += 1
yy5:
	{ err = ErrUnrecognizedToken; return }
yy6:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '\t') {
		goto yy6
	}
	if (yych == ' ') {
		goto yy6
	}
	{
			continue
		}
yy9:
	l.cursor += 1
	{
			if l.insertSemi() {
				l.cursor = l.token // Has the effect of "inserting" the semicolon in the input
				tok = token.Semicolon
				lit = "\n"
				return
			} else {
				l.file.AddLine(l.token)
				continue
			}
		}
yy11:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '\n') {
		goto yy9
	}
	goto yy5
yy12:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '=') {
		goto yy70
	}
	{ tok = token.Bang; lit = "!"; return }
yy14:
	l.cursor += 1
	{ return l.lexString('"') }
yy16:
	l.cursor += 1
	{
            pos, tok, lit, err = l.lexString('\'')
            if tok == token.String {
                tok = token.Atom
            }
            return
        }
yy18:
	l.cursor += 1
	{ tok = token.LParen; lit = "("; return }
yy20:
	l.cursor += 1
	{ tok = token.RParen; lit = ")"; return }
yy22:
	l.cursor += 1
	{ tok = token.Star; lit = "*"; return }
yy24:
	l.cursor += 1
	{ tok = token.Plus; lit = "+"; return }
yy26:
	l.cursor += 1
	{ tok = token.Comma; lit = ","; return }
yy28:
	l.cursor += 1
	{ tok = token.Minus; lit = "-"; return }
yy30:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '/') {
		goto yy31
	}
	if (yych <= '9') {
		goto yy72
	}
yy31:
	{ tok = token.Period; lit = "."; return }
yy32:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '*') {
		goto yy75
	}
	if (yych == '/') {
		goto yy77
	}
	{ tok = token.Slash; lit = "/"; return }
yy34:
	yyaccept = 0
	l.cursor += 1
	l.marker = l.cursor
	yych = l.input[l.cursor]
	if (yych <= '9') {
		if (yych == '.') {
			goto yy72
		}
		if (yych >= '0') {
			goto yy80
		}
	} else {
		if (yych <= 'E') {
			if (yych >= 'E') {
				goto yy83
			}
		} else {
			if (yych == 'e') {
				goto yy83
			}
		}
	}
yy35:
	{ tok = token.Integer; lit = l.literal(); return }
yy36:
	yyaccept = 0
	l.cursor += 1
	l.marker = l.cursor
	yych = l.input[l.cursor]
	if (yych <= '9') {
		if (yych == '.') {
			goto yy72
		}
		if (yych <= '/') {
			goto yy35
		}
		goto yy36
	} else {
		if (yych <= 'E') {
			if (yych <= 'D') {
				goto yy35
			}
			goto yy83
		} else {
			if (yych == 'e') {
				goto yy83
			}
			goto yy35
		}
	}
yy38:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '=') {
		goto yy84
	}
	{ tok = token.Colon; lit = ":"; return }
yy40:
	l.cursor += 1
	{ tok = token.Semicolon; lit = ";"; return }
yy42:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '=') {
		goto yy86
	}
	{ tok = token.Less; lit = "<"; return }
yy44:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '=') {
		goto yy88
	}
	{ tok = token.Equal; lit = "="; return }
yy46:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '=') {
		goto yy90
	}
	{ tok = token.Greater; lit = ">"; return }
yy48:
	l.cursor += 1
	yych = l.input[l.cursor]
yy49:
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy50
		}
		if (yych <= '9') {
			goto yy48
		}
		if (yych >= 'A') {
			goto yy48
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy48
			}
		} else {
			if (yych <= '`') {
				goto yy50
			}
			if (yych <= 'z') {
				goto yy48
			}
		}
	}
yy50:
	{ tok = token.Identifier; lit = l.literal(); return }
yy51:
	l.cursor += 1
	{ tok = token.LSquareBracket; lit = "["; return }
yy53:
	l.cursor += 1
	{ tok = token.RSquareBracket; lit = "]"; return }
yy55:
	l.cursor += 1
	{ return l.lexRawString('`') }
yy57:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy92
	}
	goto yy49
yy58:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy93
	}
	goto yy49
yy59:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'u') {
		goto yy94
	}
	goto yy49
yy60:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'm') {
		goto yy95
	}
	goto yy49
yy61:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy96
	}
	goto yy49
yy62:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy97
	}
	goto yy49
yy63:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'y') {
		goto yy98
	}
	goto yy49
yy64:
	l.cursor += 1
	{ tok = token.LCurlyBracket; lit = "{"; return }
yy66:
	l.cursor += 1
	{ tok = token.Pipe; lit = "|"; return }
yy68:
	l.cursor += 1
	{ tok = token.RCurlyBracket; lit = "}"; return }
yy70:
	l.cursor += 1
	{ tok = token.BangEqual; lit = "!="; return }
yy72:
	yyaccept = 1
	l.cursor += 1
	l.marker = l.cursor
	yych = l.input[l.cursor]
	if (yych <= 'D') {
		if (yych <= '/') {
			goto yy74
		}
		if (yych <= '9') {
			goto yy72
		}
	} else {
		if (yych <= 'E') {
			goto yy83
		}
		if (yych == 'e') {
			goto yy83
		}
	}
yy74:
	{ tok = token.Float; lit = l.literal(); return }
yy75:
	yyaccept = 2
	l.cursor += 1
	l.marker = l.cursor
	yych = l.input[l.cursor]
	if (yych >= 0x01) {
		goto yy100
	}
yy76:
	{ return l.lexMultiComment() }
yy77:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '\n') {
		if (yych <= 0x00) {
			goto yy79
		}
		if (yych <= '\t') {
			goto yy77
		}
	} else {
		if (yych != '\r') {
			goto yy77
		}
	}
yy79:
	{ tok = token.Comment; lit = l.literal(); return }
yy80:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '9') {
		if (yych == '.') {
			goto yy72
		}
		if (yych >= '0') {
			goto yy80
		}
	} else {
		if (yych <= 'E') {
			if (yych >= 'E') {
				goto yy83
			}
		} else {
			if (yych == 'e') {
				goto yy83
			}
		}
	}
yy82:
	l.cursor = l.marker
	if (yyaccept <= 1) {
		if (yyaccept == 0) {
			goto yy35
		} else {
			goto yy74
		}
	} else {
		goto yy76
	}
yy83:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= ',') {
		if (yych == '+') {
			goto yy102
		}
		goto yy82
	} else {
		if (yych <= '-') {
			goto yy102
		}
		if (yych <= '/') {
			goto yy82
		}
		if (yych <= '9') {
			goto yy103
		}
		goto yy82
	}
yy84:
	l.cursor += 1
	{ tok = token.ColonEqual; lit = ":="; return }
yy86:
	l.cursor += 1
	{ tok = token.LessEqual; lit = "<="; return }
yy88:
	l.cursor += 1
	{ tok = token.EqualEqual; lit = "=="; return }
yy90:
	l.cursor += 1
	{ tok = token.GreaterEqual; lit = ">="; return }
yy92:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 's') {
		goto yy105
	}
	goto yy49
yy93:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'u') {
		goto yy106
	}
	goto yy49
yy94:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy107
	}
	goto yy49
yy95:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy108
	}
	goto yy49
yy96:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy109
	}
	if (yych == 't') {
		goto yy111
	}
	goto yy49
yy97:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy112
	}
	goto yy49
yy98:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy113
	}
	goto yy49
yy99:
	l.cursor += 1
	yych = l.input[l.cursor]
yy100:
	if (yych <= 0x00) {
		goto yy82
	}
	if (yych != '*') {
		goto yy99
	}
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '/') {
		goto yy114
	}
	goto yy99
yy102:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '/') {
		goto yy82
	}
	if (yych >= ':') {
		goto yy82
	}
yy103:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '/') {
		goto yy74
	}
	if (yych <= '9') {
		goto yy103
	}
	goto yy74
yy105:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy116
	}
	goto yy49
yy106:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'm') {
		goto yy118
	}
	goto yy49
yy107:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy120
	}
	goto yy49
yy108:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'o') {
		goto yy122
	}
	goto yy49
yy109:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy110
		}
		if (yych <= '9') {
			goto yy48
		}
		if (yych >= 'A') {
			goto yy48
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy48
			}
		} else {
			if (yych <= '`') {
				goto yy110
			}
			if (yych <= 'z') {
				goto yy48
			}
		}
	}
yy110:
	{ tok = token.Map; lit = "map"; return }
yy111:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy123
	}
	goto yy49
yy112:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'u') {
		goto yy124
	}
	goto yy49
yy113:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy125
	}
	goto yy49
yy114:
	l.cursor += 1
	{ tok = token.Comment; lit = l.literal(); return }
yy116:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy117
		}
		if (yych <= '9') {
			goto yy48
		}
		if (yych >= 'A') {
			goto yy48
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy48
			}
		} else {
			if (yych <= '`') {
				goto yy117
			}
			if (yych <= 'z') {
				goto yy48
			}
		}
	}
yy117:
	{ tok = token.Case; lit = "case"; return }
yy118:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy119
		}
		if (yych <= '9') {
			goto yy48
		}
		if (yych >= 'A') {
			goto yy48
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy48
			}
		} else {
			if (yych <= '`') {
				goto yy119
			}
			if (yych <= 'z') {
				goto yy48
			}
		}
	}
yy119:
	{ tok = token.Enum; lit = "enum"; return }
yy120:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy121
		}
		if (yych <= '9') {
			goto yy48
		}
		if (yych >= 'A') {
			goto yy48
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy48
			}
		} else {
			if (yych <= '`') {
				goto yy121
			}
			if (yych <= 'z') {
				goto yy48
			}
		}
	}
yy121:
	{ tok = token.Func; lit = "func"; return }
yy122:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'r') {
		goto yy127
	}
	goto yy49
yy123:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'h') {
		goto yy128
	}
	goto yy49
yy124:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'r') {
		goto yy130
	}
	goto yy49
yy125:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy126
		}
		if (yych <= '9') {
			goto yy48
		}
		if (yych >= 'A') {
			goto yy48
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy48
			}
		} else {
			if (yych <= '`') {
				goto yy126
			}
			if (yych <= 'z') {
				goto yy48
			}
		}
	}
yy126:
	{ tok = token.TypeKeyword; lit = "type"; return }
yy127:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy131
	}
	goto yy49
yy128:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy129
		}
		if (yych <= '9') {
			goto yy48
		}
		if (yych >= 'A') {
			goto yy48
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy48
			}
		} else {
			if (yych <= '`') {
				goto yy129
			}
			if (yych <= 'z') {
				goto yy48
			}
		}
	}
yy129:
	{ tok = token.Match; lit = "match"; return }
yy130:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy133
	}
	goto yy49
yy131:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy132
		}
		if (yych <= '9') {
			goto yy48
		}
		if (yych >= 'A') {
			goto yy48
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy48
			}
		} else {
			if (yych <= '`') {
				goto yy132
			}
			if (yych <= 'z') {
				goto yy48
			}
		}
	}
yy132:
	{ tok = token.Import; lit = "import"; return }
yy133:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy134
		}
		if (yych <= '9') {
			goto yy48
		}
		if (yych >= 'A') {
			goto yy48
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy48
			}
		} else {
			if (yych <= '`') {
				goto yy134
			}
			if (yych <= 'z') {
				goto yy48
			}
		}
	}
yy134:
	{ tok = token.Return; lit = "return"; return }
}

    }
}

func (l *Lexer) lexString(quote byte) (pos token.Pos, tok token.Type, lit string, err error) {
	var buf bytes.Buffer
	buf.WriteByte(quote)
	for {
		var u byte

{
	var yych byte
	yych = l.input[l.cursor]
	if (yych <= '\n') {
		if (yych <= 0x00) {
			goto yy137
		}
		if (yych <= '\t') {
			goto yy139
		}
		goto yy141
	} else {
		if (yych == '\\') {
			goto yy143
		}
		goto yy139
	}
yy137:
	l.cursor += 1
	{
			err = ErrUnterminatedString
			tok = token.EOF
            pos = l.file.Pos(l.token)
			return
		}
yy139:
	l.cursor += 1
	{
			u = yych
			buf.WriteByte(u)
			if u == quote {
				tok = token.String
				pos = l.file.Pos(l.token)
				lit = string(buf.Bytes())
				return
			}
			continue
		}
yy141:
	l.cursor += 1
yy142:
	{ err = ErrInvalidString; return }
yy143:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'b') {
		if (yych <= '>') {
			if (yych <= '"') {
				if (yych <= '!') {
					goto yy142
				}
			} else {
				if (yych == '\'') {
					goto yy146
				}
				goto yy142
			}
		} else {
			if (yych <= '\\') {
				if (yych <= '?') {
					goto yy148
				}
				if (yych <= '[') {
					goto yy142
				}
				goto yy150
			} else {
				if (yych <= '`') {
					goto yy142
				}
				if (yych <= 'a') {
					goto yy152
				}
				goto yy154
			}
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'f') {
				if (yych <= 'e') {
					goto yy142
				}
				goto yy156
			} else {
				if (yych == 'n') {
					goto yy158
				}
				goto yy142
			}
		} else {
			if (yych <= 't') {
				if (yych <= 'r') {
					goto yy160
				}
				if (yych <= 's') {
					goto yy142
				}
				goto yy162
			} else {
				if (yych == 'v') {
					goto yy164
				}
				goto yy142
			}
		}
	}
	l.cursor += 1
	{ buf.WriteByte('"'); continue }
yy146:
	l.cursor += 1
	{ buf.WriteByte('\''); continue }
yy148:
	l.cursor += 1
	{ buf.WriteByte('?'); continue }
yy150:
	l.cursor += 1
	{ buf.WriteByte('\\'); continue }
yy152:
	l.cursor += 1
	{ buf.WriteByte('\a'); continue }
yy154:
	l.cursor += 1
	{ buf.WriteByte('\b'); continue }
yy156:
	l.cursor += 1
	{ buf.WriteByte('\f'); continue }
yy158:
	l.cursor += 1
	{ buf.WriteByte('\n'); continue }
yy160:
	l.cursor += 1
	{ buf.WriteByte('\r'); continue }
yy162:
	l.cursor += 1
	{ buf.WriteByte('\t'); continue }
yy164:
	l.cursor += 1
	{ buf.WriteByte('\v'); continue }
}
		
	}
}

func (l *Lexer) lexRawString(quote byte) (pos token.Pos, tok token.Type, lit string, err error) {
	for {

{
	var yych byte
	yych = l.input[l.cursor]
	if (yych >= 0x01) {
		goto yy170
	}
	l.cursor += 1
	{
			err = ErrUnterminatedString
			tok = token.EOF
            pos = l.file.Pos(l.token)
			return
		}
yy170:
	l.cursor += 1
	{
			if yych == quote {
				tok = token.String
				pos = l.file.Pos(l.token)
				lit = string(l.input[l.token:l.cursor])
				return
			}
			continue
		}
}
		
	}
}

func (l *Lexer) lexMultiComment() (pos token.Pos, tok token.Type, lit string, err error) {
	for {

{
	var yych byte
	yych = l.input[l.cursor]
	if (yych <= 0x00) {
		goto yy174
	}
	if (yych == '*') {
		goto yy178
	}
	goto yy176
yy174:
	l.cursor += 1
	{
			err = ErrUnterminatedComment
			tok = token.EOF
            pos = l.file.Pos(l.token)
			return
		}
yy176:
	l.cursor += 1
yy177:
	{ continue }
yy178:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych != '/') {
		goto yy177
	}
	l.cursor += 1
	{
			tok = token.Comment
			pos = l.file.Pos(l.token)
			lit = string(l.input[l.token+2:l.cursor])
			return
		}
}
		
	}
}