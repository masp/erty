// Package compiler emits Core Erlang from the AST generated by the parser.
package compiler

import (
	"fmt"
	"strings"

	"github.com/masp/ertylang/ast"
	"github.com/masp/ertylang/core"
	"github.com/masp/ertylang/parser"
	"github.com/masp/ertylang/resolver"
	"github.com/masp/ertylang/token"
	"github.com/masp/ertylang/types"
)

type Compiler struct {
	file    *token.File
	errors  token.ErrorList
	mapping *Environment
}

func (c *Compiler) push() { c.mapping = c.mapping.push() }
func (c *Compiler) pop()  { c.mapping = c.mapping.Outer }
func (c *Compiler) declare(id *ast.Identifier) *core.Var {
	return c.newVar(id.Name, id.Type())
}

// newVar declares a new variable with the given name. If name is empty, the variable is a temp
// and not bound to a scope.
func (c *Compiler) newVar(name string, typ ast.Type) *core.Var {
	uniq := c.mapping.uniqueId()
	if name == "" {
		name = uniq
	}
	v := &core.Var{Name: uniq, OriginalName: name}
	v.Type = types.Value(typ)
	c.mapping.bind(name, v)
	return v
}

type Environment struct {
	Outer *Environment
	Vars  map[string]*core.Var
}

func emptyMapping() *Environment {
	return &Environment{Vars: make(map[string]*core.Var)}
}

func (m *Environment) bind(varname string, to *core.Var) {
	m.Vars[varname] = to
}

func (m *Environment) lookup(varname string) *core.Var {
	if found, ok := m.Vars[varname]; ok {
		return found
	}
	if m.Outer != nil {
		return m.Outer.lookup(varname)
	}
	return nil
}

func (m *Environment) push() *Environment {
	return &Environment{Vars: make(map[string]*core.Var), Outer: m}
}

func (m *Environment) uniqueId() string {
	var i int
	curr := m
	for curr != nil {
		i += len(curr.Vars)
		curr = curr.Outer
	}
	return fmt.Sprintf("_%d", i)
}

func New() *Compiler {
	return &Compiler{
		mapping: emptyMapping(),
	}
}

func (c *Compiler) CompileModule(mod *ast.Module) (*core.Module, error) {
	c.file = mod.File
	cmod := c.compileModule(mod)
	addBaseFuncs(cmod)
	return cmod, c.errors.Err()
}

func (c *Compiler) CompileFunction(file *token.File, fn *ast.FuncDecl) (*core.Func, error) {
	c.file = file
	cfun := c.compileFunction(fn)
	return cfun, c.errors.Err()
}

func (c *Compiler) error(node ast.Node, format string, args ...any) {
	c.errors.Add(c.file.Position(node.Pos()), fmt.Errorf(format, args...))
}

// compileModule compiles a module AST into a Core Erlang module.
func (c *Compiler) compileModule(mod *ast.Module) *core.Module {
	coreMod := &core.Module{
		Name: mod.Id.Name,
	}

	for _, decl := range mod.Decls {
		switch d := decl.(type) {
		case *ast.FuncDecl:
			coreFn := c.compileFunction(d)
			if d.IsPublic() {
				coreMod.Exports = append(coreMod.Exports, coreFn.Name)
			}
			coreMod.Functions = append(coreMod.Functions, coreFn)
		case *ast.ImportDecl:
			continue // just ignore, not used in Core Erlang
		default:
			c.error(d, "unrecognized decl: %T", decl)
		}
	}
	return coreMod
}

func (c *Compiler) compileFunction(fn *ast.FuncDecl) *core.Func {
	c.push()
	defer c.pop()

	fnAnn := &core.ConstTuple{Elements: []core.Const{
		core.Atom{Value: "function"},
		&core.ConstTuple{
			Elements: []core.Const{core.Atom{Value: fn.Name.Name}, core.Integer{Value: int64(fn.Parameters.NumFields())}},
		},
	}}
	coreFn := &core.Func{
		Name: &core.FuncName{Name: fn.Name.Name, Arity: fn.Parameters.NumFields()},
	}
	coreFn.Annotate(fnAnn)

	for _, arg := range fn.Parameters.List {
		for _, name := range arg.Names {
			v := c.declare(name)
			v.Annotate(fnAnn)
			coreFn.Parameters = append(coreFn.Parameters, v)
		}
	}

	coreFn.Body = c.compileStatements(fn.Statements)
	return coreFn
}

func (c *Compiler) compileStatements(stmts []ast.Statement) core.Expr {
	if len(stmts) == 0 {
		// A totally empty body is just a function that returns 'void' always
		return &core.Atom{Value: "void"}
	}

	// ptr to tree position where to store next expression.
	var root core.Expr
	var curr *core.Expr = &root
	for i, stmt := range stmts {
		switch stmt := stmt.(type) {
		case *ast.ReturnStatement:
			*curr = c.compileExpr(stmt.Expression)
		case *ast.ExprStatement:
			switch x := stmt.Expression.(type) {
			case *ast.MatchAssignExpr:
				let := c.compileLet(x)
				*curr = let
				curr = &let.In
			default:
				if i == len(stmts)-1 {
					*curr = c.compileExpr(x) // terminal node
					break
				}
				// Otherwise, if the statement expression is just a plain value, we
				// just wrap it in a do statement to support sequencing.
				do := &core.DoExpr{}
				do.Before = c.compileExpr(x)
				*curr = do
				curr = &do.After
			}
		default:
			c.error(stmt, "unsupported statement: %T", stmt)
			return &core.BadExpr{}
		}
	}
	return root
}

func (c *Compiler) compileExpr(expr ast.Expression) core.Expr {
	switch expr := expr.(type) {
	case *ast.IntLiteral:
		return core.Integer{Value: expr.Value}
	case *ast.Identifier:
		found := c.mapping.lookup(expr.Name)
		if found == nil {
			c.error(expr, "unbound variable %s", expr.Name)
		}
		return found
	case *ast.Field:
		return c.compileField(expr)
	case *ast.AtomLiteral:
		return core.Atom{Value: expr.Value}
	case *ast.ListLiteral:
		return c.compileList(expr)
	case *ast.StringLiteral:
		return c.compileString(expr)
	case *ast.CallExpr:
		return c.compileCallExpr(expr)
	case *ast.BinaryExpr:
		return c.compileBinary(expr)
	case *ast.Match:
		return c.compileMatch(expr)
	default:
		panic(fmt.Errorf("unrecognized expression type: %T", expr))
	}
}

// Token operation to BIF
var tokenToBIF = map[token.Type]core.Atom{
	token.Plus:  {Value: "+"},
	token.Minus: {Value: "-"},
	token.Star:  {Value: "*"},
	token.Slash: {Value: "/"},
}

func (c *Compiler) compileBinary(expr *ast.BinaryExpr) (result core.Expr) {
	left, wrap := c.pushVar(expr.Left)
	defer wrap(&result)
	right, wrap := c.pushVar(expr.Right)
	defer wrap(&result)

	bif := tokenToBIF[expr.Op]
	if bif.Value == "" {
		c.error(expr, "unsupported binary operator: %s", expr.Op)
		return core.Atom{Value: "bad_binary"}
	}
	return &core.InterModuleCall{
		Module: core.Atom{Value: "erlang"},
		Func:   tokenToBIF[expr.Op],
		Args:   []core.Expr{left, right},
	}
}

func (c *Compiler) compileLet(assign *ast.MatchAssignExpr) (result *core.LetExpr) {
	result = &core.LetExpr{}
	result.Assign = c.compileExpr(assign.Right) // evaluate assignment with existing mapping
	id, ok := assign.Left.(*ast.Identifier)
	if !ok {
		panic("TODO: Add support for matching expressions/patterns")
	}
	c.push()
	result.Vars = append(result.Vars, c.declare(id))
	return result
}

func (c *Compiler) compileList(list *ast.ListLiteral) core.Expr {
	var elements []core.Expr
	for _, elem := range list.Elts {
		elements = append(elements, c.compileExpr(elem))
	}
	return &core.List{Elements: elements}
}

func (c *Compiler) compileCallExpr(call *ast.CallExpr) core.Expr {
	switch expr := call.Fun.(type) {
	case *ast.DotExpr:
		return c.compileDotCallExpr(call, expr)
	default: // local function, we can validate that the function exists
		return c.compileLocalCallExpr(call)
	}
}

func (c *Compiler) compileLocalCallExpr(expr *ast.CallExpr) (result core.Expr) {
	// If an identifier and identifier is not defined in function as variable,
	// treat as an atom
	fnType := expr.Fun.Type()
	if _, ok := types.Deref(fnType).(*types.Expr); ok {
		// Type cast expression, we can ignore this unless we need to do a conversion
		// TODO: Support conversions (e.g. float -> int)
		if len(expr.Args) != 1 {
			c.error(expr, "type cast must only have 1 arg: %s", expr.Fun.Type())
			return &core.BadExpr{}
		}
		return c.compileExpr(expr.Args[0])
	}

	if _, ok := types.Value(fnType).(*types.Func); !ok {
		c.error(expr.Fun, "unsupported call operation: expected function, got %s", expr.Fun.Type())
		return &core.BadExpr{}
	}

	// If we refer to a locally defined function, we should reference it with atom/arity
	// otherwise, it's probably a locally defined lambda expr and should be referenced by compiling and
	// pushing it into a let.
	var fnName core.Expr
	decl := types.DeclNode(fnType)
	if fnDecl, ok := decl.(*ast.FuncDecl); ok {
		fnName = &core.Arity{
			Name:  core.Atom{Value: fnDecl.Name.Name},
			Arity: fnDecl.Parameters.NumFields(),
		}
	} else {
		f, wrap := c.pushVar(expr.Fun)
		defer wrap(&result)
		fnName = f
	}

	// apply can only accept variables as arguments, so we need to wrap any
	var args []core.Expr
	for _, arg := range expr.Args {
		arg, wrap := c.pushVar(arg)
		args = append(args, arg)
		defer wrap(&result)
	}

	return &core.ApplyExpr{
		Func: fnName,
		Args: args,
	}
}

// pushVar pushes a variable to the stack and returns the reference to it or if it
// is already a reference, just the value.

// Because let expressions can be nested, and must be before the expression the var
// is used in, we need to wrap the existing expression which is why a the wrap func is returned as well.
func (c *Compiler) pushVar(expr ast.Expression) (core.Expr, func(*core.Expr)) {
	switch expr.(type) {
	case *ast.Identifier, *ast.AtomLiteral, *ast.IntLiteral, *ast.FloatLiteral:
		// These values do not need to be wrapped in a let expression
		return c.compileExpr(expr), func(*core.Expr) {}
	default:
		tmp := c.newVar("", expr.Type())
		let := &core.LetExpr{
			Vars:   []*core.Var{tmp},
			Assign: c.compileExpr(expr),
			// In to be assigned in wrap()
		}

		wrap := func(toWrap *core.Expr) {
			let.In = *toWrap
			*toWrap = let
		}
		return tmp, wrap
	}
}

func (c *Compiler) compileDotCallExpr(call *ast.CallExpr, dot *ast.DotExpr) (result core.Expr) {
	// If an identifier and identifier is not defined in function as variable,
	// treat as an atom
	module := dot.X
	if ident, ok := dot.X.(*ast.Identifier); ok {
		module = &ast.AtomLiteral{Value: ident.Name}
	}

	var args []core.Expr
	for _, arg := range call.Args {
		v, wrap := c.pushVar(arg)
		args = append(args, v)
		defer wrap(&result)
	}

	return &core.InterModuleCall{
		Module: c.compileExpr(module),
		Func:   core.Atom{Value: dot.Attr.Name},
		Args:   args,
	}
}

func (c *Compiler) compileString(str *ast.StringLiteral) core.Expr {
	result := &core.Binary{}
	raw := []byte(str.Value)
	for i := 0; i < len(raw); i++ {
		result.Bits = append(result.Bits, &core.Bitstring{
			Val:    core.Integer{Value: int64(raw[i])},
			Length: core.Integer{Value: 1},
			Type:   core.BitTypeInteger,
			Unit:   core.BitUnitByte,
			Flags:  core.BitStringFlags,
		})
	}
	return result
}

// commonModFuncs are default funcs that are included in every Erlang module
// If these are not included, the Erlang VM will not be able to load the module.
func commonModFuncs(modname string) string {
	return strings.NewReplacer("{{mod}}", modname).Replace(`
module common

import "erlang"

func module_info() any {
	return erlang.module_info(module('{{mod}}'))
}

func module_info(key atom) any {
	return erlang.module_info(module('{{mod}}'), key)
}
`)
}

// addBaseFuncs adds the module_info functions that Erlang requires as part of every
// module.
//
// The functions are very simple: just call 'erlang':module_info/1 with the appropriate atom.
func addBaseFuncs(cmod *core.Module) {
	commonMod, err := parser.ParseModule("<builtin>", []byte(commonModFuncs(cmod.Name)), nil)
	if err != nil {
		panic(err)
	}

	err = resolver.ResolveModule(commonMod, &resolver.Config{Importer: resolver.BuiltinsImporter})
	if err != nil {
		panic(err)
	}
	cmpl := New()
	cmpl.file = commonMod.File
	common := cmpl.compileModule(commonMod)
	if len(cmpl.errors) > 0 {
		panic(cmpl.errors.Err())
	}
	cmod.Functions = append(cmod.Functions, common.Functions...)
	cmod.Exports = append(cmod.Exports, common.Exports...)
}
